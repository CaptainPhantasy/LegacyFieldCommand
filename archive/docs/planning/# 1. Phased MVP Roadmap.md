# Legacy Field Command - Phased MVP Roadmap
### Phase 0 – Foundations (Backend + Auth + Roles)
* •	Stand up Supabase project:
  * ◦	Postgres schema v1
  * ◦	Auth (email/password + optional magic link)
  * ◦	Role-based access (field tech, lead tech, estimator, admin, owner).
* •	Define core entities:
  * ◦	Accounts, Users, Roles
  * ◦	Leads, Jobs, JobStages
  * ◦	Contacts (policyholder, adjuster, carrier, TPA, vendor)
  * ◦	Photos & Evidence
  * ◦	Policies
  * ◦	Estimates & Line Items
  * ◦	AuditLogs, Alerts
* •	Implement **backup/DR strategy** with Supabase + object storage (see section 3).
* •	Set up minimal admin web UI for internal team.

⠀Phase 1 – Field App + Gates + Photo Evidence (with Offline)
* •	Build **Lead Tech field app** (React Native or similar) with:
  * ◦	Guided visit flow (arrival → intake → photos → moisture/equipment → scope → sign-offs → departure).
  * ◦	Unskippable gates + exception logging.
  * ◦	“Dummy-proof” UI with picklists/buttons/templates.
* •	Implement **Photo / Evidence capture** flows:
  * ◦	Room-based workflows
  * ◦	Mandatory metadata
  * ◦	PPE evidence
* •	Implement **offline-first** local database on device using WatermelonDB, with background sync to Supabase.

⠀Phase 2 – CRM Core + Policy Ingestion + Communications
* •	Build **CRM / core platform** (web) for office/admin:
  * ◦	Lead → inspection → job → invoicing pipeline view.
  * ◦	Contact management per job.
* **•	Policy ingestion & coverage logic MVP**:
  * ◦	Upload policy PDF → extract key limits/deductible/special sublimits.
  * ◦	Generate plain-language coverage summary.
  * ◦	Enforce “no coverage-dependent finalization without policy on file / override.”
* **•	Communication & voice agents (MVP)**:
  * ◦	Voice note capture in field app + web.
  * ◦	Transcribe → structure into notes/quote elements.
  * ◦	Email sending: templated quotes/updates/requests.

⠀Phase 3 – AI Estimate Engine (v1) + Alerts/Monitoring
* •	Build **AI quoting & estimating v1**:
  * ◦	Take structured data (photos/metadata, notes, measurements, job type, policy coverage summary).
  * ◦	Generate internal line-item estimate mapped to “Gen/core” codes.
  * ◦	Basic mapping/export to Xactimate-friendly format (e.g., CSV/Excel or API stub).
  * ◦	Apply coverage logic (deductibles, limits; mark non-covered items).
* •	Build **Alerts & monitoring**:
  * ◦	Missed opportunity watchdog (stale leads/conversations).
  * ◦	Gate/fudging alerts (missing artifacts, bypass attempts).
  * ◦	Basic dashboards (jobs by stage, revenue pending, response-time, compliance %).

⠀Phase 4 – Program vs Non-Program Templates + 3D Future-Proofing
* •	Implement **Program vs Non-Program workflows**:
  * ◦	Job templates by carrier/program with required gates/fields/artifacts.
  * ◦	Stub integrations for CoreLogic/NextGen (e.g., data export format, API-ready structure).
* **•	3D Imaging & Measurement future-proofing**:
  * ◦	Data model for 3D scans / LiDAR / floorplans.
  * ◦	Ability to upload/link measurement files and map to rooms/line-items.
  * ◦	No need to build full 3D UI yet; just ingestion + linking.

⠀
# 2. Epics / Modules (MVP Scope)
### Epic 1 – Field App & “Lead Tech as Sales” Workflow
**Goals**
* •	Make on-site lead tech a guided sales/ops user.
* •	Impossible to skip key steps or fudge data without leaving a trail.

⠀**MVP Features**
* •	Guided visit flow (per job):
  * ◦	Steps: arrival → intake → photos → moisture/equipment → scope → sign-offs → departure.
  * ◦	Each step is a **gate** with “Complete” state only if:
    * ▪	Required data present **OR**
    * ▪	An exception with reason + optional photo is logged.
* •	“Dummy-proof” UX:
  * ◦	Minimal free-text: heavy use of buttons, picklists, templates.
  * ◦	Context-aware prompts:
    * ▪	After setting room to “Kitchen,” auto show checklist: angles, affected surfaces, cabinets, floor, ceiling, etc.
* •	Anti-fudging logic:
  * ◦	If a gate is marked complete but required photos/metrics missing:
    * ▪	Block completion **or** force “Exception reason” capture.
    * ▪	Automatically log event in AuditLogs.
    * ▪	Trigger gate-alert event for Alerting module.
* •	Role-based accountability:
  * ◦	Device user → Supabase user → every action stamped: user_id, job_id, timestamp, location (when available).
  * ◦	“Sign-off owner” clearly distinguished from other contributors.

⠀**Offline (WatermelonDB)**
* •	Local schemas: jobs, rooms, visits, gates, photos (metadata), notes, exceptions.
* •	Sync engine:
  * ◦	On login / reconnect:
    * ▪	Pull assigned jobs + latest state.
  * ◦	On change:
    * ▪	Save to WatermelonDB; queue mutations.
  * ◦	When online:
    * ▪	Flush queued mutations to Supabase via REST/RPC.
    * ▪	Resolve conflicts with simple rules (e.g., latest timestamp wins / server authoritative).

⠀
### Epic 2 – Photo / Evidence Capture & Gates
**Goals**
* •	Standardized, defensible documentation that can drive AI and satisfy carriers.

⠀**MVP Features**
* •	Photo gates at key steps:
  * ◦	Arrival photos.
  * ◦	Room-by-room photos.
  * ◦	Post-mitigation photos.
  * ◦	PPE photos.
* •	Mandatory metadata for each photo:
  * ◦	Room (select from room list or add via picklist).
  * ◦	What is affected (e.g., “North wall drywall 2 ft up” from quick labels).
  * ◦	Automatic tags from context when possible (e.g., gate name, step, timestamp, user).
* •	Bulk & guided capture:
  * ◦	“Start room” workflow:
    * ▪	Show checklist: wide room shot, perimeter walls, floor, ceiling, close-ups of damage, equipment placement.
  * ◦	Sequential capture with auto-labeling:
    * ▪	Pre-fill room + step; user only selects “type” from a small list.
* •	PPE & safety:
  * ◦	Require at least one PPE shot per visit where PPE required.
  * ◦	Link PPE photos to job + visit instance.
* •	Storage & linkage:
  * ◦	Supabase Storage (bucket) for raw images.
  * ◦	DB rows for each photo:
    * ▪	job_id, room_id, step/gate, user_id, timestamp, geo (if available), labels.
  * ◦	Evidence package generation (MVP):
    * ▪	Export: ZIP of photos + JSON/CSV manifest.
    * ▪	Later: PDF report.

⠀
### Epic 3 – 3D Imaging & Measurement (Future-Proofed v1)
**Goals**
* •	Schema + upload pipeline ready for 3D/LiDAR in v2+, with minimal but real v1 capability.

⠀**MVP Features**
* •	Data model:
  * ◦	scans table: job_id, room_id, scan_type (LiDAR, 3D model, floorplan), file_reference, metadata.
  * ◦	measurements table: job_id, room_id, type (sqft, linear_ft, volume), value, source.
* •	File ingestion:
  * ◦	Upload 3D files or floorplans (PDF, OBJ, GLTF, or raw LiDAR output) to storage bucket.
  * ◦	Link them to job/room.
* •	Mapping to estimate:
  * ◦	UI to input / confirm key measurement numbers (sqft, linear ft) derived from scan.
  * ◦	Store these as measurement rows that the estimating engine can consume.

⠀
### Epic 4 – AI Quoting & Estimating Engine (v1)
**Goals**
* •	Turn field data + policy into carrier-ready estimates with guardrails.

⠀**MVP Features**
* •	Inputs:
  * ◦	Structured job data (damage types, rooms, affected areas).
  * ◦	Photos/metadata.
  * ◦	Basic measurements (manual or from scans).
  * ◦	Job type + loss type.
  * ◦	Policy coverage summary (deductibles/limits).
  * ◦	Voice-captured notes converted to structured bullets.
* •	Core capabilities:
  * ◦	Generate internal line-item estimate:
    * ▪	Use internal Gen/core codes.
    * ▪	Save line items with qty, unit cost, total, coverage bucket (insurance, customer-pay, non-covered).
  * ◦	Xactimate alignment (v1):
    * ▪	Map each internal code to an Xactimate code where available.
    * ▪	Generate export file (CSV/Excel or JSON) that can be imported to Xactimate.
* •	Scrubbing & dual-system support (MVP):
  * ◦	Import Xactimate output (e.g., CSV/JSON).
  * ◦	Compare totals & line items to internal estimate.
  * ◦	Flag:
    * ▪	% variance over threshold.
    * ▪	Missing/extra codes.
* •	QA & compliance:
  * ◦	Configurable thresholds per account (e.g., >10% variance triggers review).
  * ◦	Log every revision:
    * ▪	estimator_id, timestamp, change summary.
* •	Coverage buckets:
  * ◦	Fields on each line item: coverage_bucket (insurance, customer-pay, non-covered).
  * ◦	Enforcement:
    * ▪	Coverage logic applies limits/deductibles to insurance-billable items.
    * ▪	Non-covered items kept separate for customer explanation.

⠀
### Epic 5 – Policy Ingestion & Coverage Logic
**Goals**
* •	Understand coverage before advising/pricing; enforce “no advice without policy.”

⠀**MVP Features**
* •	Policy ingestion:
  * ◦	Upload one or more policy documents (PDF).
  * ◦	Use OCR + extraction pipeline to pull:
    * ▪	Limits, deductibles, exclusions, endorsements, special sublimits.
  * ◦	Store normalized policy object linked to job.
* •	Coverage summary:
  * ◦	Generate plain-language explanation for this loss type:
    * ▪	What is covered.
    * ▪	What is not covered.
    * ▪	Key sublimits and deductibles that apply.
* •	System controls:
  * ◦	For flagged “coverage-dependent” actions (e.g., final estimate, representation commitment):
    * ▪	Require:
      * ▪	Policy on file, and
      * ▪	Parsed successfully **or** manual reviewed override with reason.
* •	Data usage:
  * ◦	Estimating engine uses coverage object:
    * ▪	Apply deductibles and limits to relevant buckets.
    * ▪	Flag items that appear non-covered.
  * ◦	Customer-facing explanation:
    * ▪	One-click generate “Here’s what’s covered and not covered” letter/email template.

⠀
### Epic 6 – CRM / Core Platform
**Goals**
* •	One backbone system for leads, jobs, communication, billing, and integrations.

⠀**MVP Features**
* •	Lead & job lifecycle:
  * ◦	Entities: Lead, Job, JobStage, Invoice.
  * ◦	Pipeline:
    * ▪	Lead → inspection scheduled → job created → active work → ready to invoice → paid/closed.
  * ◦	List & board views for dispatch/sales/ops.
* •	Contact management:
  * ◦	For each job:
    * ▪	Policyholder.
    * ▪	Adjuster.
    * ▪	Carrier.
    * ▪	TPA.
    * ▪	Vendors.
* •	Integrations (MVP level):
  * ◦	Xactimate:
    * ▪	Export estimates into Xactimate-friendly format.
    * ▪	Later: webhooks/API integration.
  * ◦	CoreLogic/NextGen:
    * ▪	For now: allow export of key job fields/documents in expected formats.
* •	Equipment & truck inventory:
  * ◦	Map estimated scope to expected equipment & materials.
  * ◦	Basic tracking: what equipment was deployed vs expected, per job.

⠀
### Epic 7 – Communications & Voice/AI Agents
**Goals**
* •	Voice-driven data entry, email-first outbound.

⠀**MVP Features**
* •	Voice agents:
  * ◦	In the field app & web:
    * ▪	“Record note” → audio.
    * ▪	Transcribe via speech-to-text.
    * ▪	Interpret into structured fields:
      * ▪	Damage descriptions.
      * ▪	Customer notes.
      * ▪	Quote elements.
* •	Outbound channels (MVP: email only):
  * ◦	Templated emails triggered by workflow:
    * ▪	Quote sent.
    * ▪	Job update.
    * ▪	Request for photos/signatures.
  * ◦	Voice agent trigger:
    * ▪	“Send the preliminary quote to the adjuster” → pre-filled email with estimate summary and attachments.
* •	Future (deferred, but mention in PRD):
  * ◦	SMS and autodial once FCC-compliant framework in place (opt-in/out, logging, consent).

⠀
### Epic 8 – Alerts, Monitoring & Observability
**Goals**
* •	Real-time awareness of misses, fudging, and system health.

⠀**MVP Features**
* •	Missed-opportunity watchdog:
  * ◦	Monitor:
    * ▪	New leads with no initial response within X minutes.
    * ▪	Open customer emails not replied to in Y hours.
  * ◦	For each:
    * ▪	Create AI-draft reply (for internal review).
    * ▪	Send alert to assigned owner (email + in-app notification).
* •	Gate/fudging alerts:
  * ◦	Trigger when:
    * ▪	Gate marked complete without required artifacts.
    * ▪	Exception reasons over certain frequency.
    * ▪	Fields inconsistent (e.g., “flood in kitchen” but no kitchen photos).
  * ◦	Mark job/step as “needs review.”
  * ◦	Notify admins/QA.
* •	Observability dashboards:
  * ◦	Jobs by stage.
  * ◦	Revenue by stage (pending/collected).
  * ◦	Response time metrics (avg time-to-first-contact).
  * ◦	Quality/compliance metrics:
    * ▪	% of jobs with all required photo gates passed.
    * ▪	% of jobs with policies on file before final estimate.

⠀
### Epic 9 – Security, Roles & Audit Trails
**Goals**
* •	Carrier-grade defensibility and internal accountability.

⠀**MVP Features**
* •	Role-based access:
  * ◦	Roles: Field Tech, Lead Tech, Estimator, Admin, Owner (plus Program Admin as needed).
  * ◦	Permissions matrix:
    * ▪	Who can edit estimates.
    * ▪	Who can override gates.
    * ▪	Who can change policy coverage interpretation.
* •	Audit logs:
  * ◦	For:
    * ▪	Estimates & line items.
    * ▪	Coverage interpretations/overrides.
    * ▪	Gate overrides.
    * ▪	Communications (who sent what, when).
* •	Tamper-resistant storage:
  * ◦	Critical objects (photos, PPE evidence, decision logs):
    * ▪	Immutable log entries for key decisions (append-only).
    * ▪	Audit pointer in DB + storage location.

⠀
### Epic 10 – Program vs Non-Program Workflows
**Goals**
* •	Support both private jobs and carrier/TPA program requirements.

⠀**MVP Features**
* •	Non-program jobs:
  * ◦	Default job template:
    * ▪	Internal platform + Xactimate export is enough.
    * ▪	Evidence package for customer/attorney (ZIP + manifest / simple PDF).
* •	Program jobs:
  * ◦	Configuration:
    * ▪	Job templates per carrier/program.
    * ▪	Additional required fields, statuses, & artifacts.
  * ◦	Synchronization concept:
    * ▪	Data and document sets identified that must be kept up-to-date for CoreLogic/NextGen.
    * ▪	For MVP: export-ready structures, “ready for integration.”

⠀
# 3. Addendum Items (Explicitly Worked In)
### A. Supabase Backups & Data Durability
* **•	Automated Backups**
  * ◦	Enable daily automated Postgres backups via Supabase.
  * ◦	Maintain retention policy (e.g., 30 days rolling) plus monthly snapshots.
* **•	Object Storage Buckets**
  * ◦	Use Supabase Storage (or S3 equivalent) for:
    * ▪	Raw photos and scans.
    * ▪	Evidence packages.
  * ◦	Configure versioning on critical buckets where possible.
* **•	Disaster Recovery Plan**
  * ◦	Document recovery procedures:
    * ▪	Restore database from backup.
    * ▪	Rebuild storage bucket from latest versioned objects.
  * ◦	Periodic restore test in a staging environment.

⠀B. Offline-First Field App with WatermelonDB
* •	Local-first UX:
  * ◦	The field app is fully usable without network:
    * ▪	Job list (assigned to that tech/crew).
    * ▪	Gates & checklists.
    * ▪	Photo capture + metadata.
    * ▪	Notes, exceptions, timestamps.
* •	Sync Strategy:
  * ◦	On app start / periodic heartbeat:
    * ▪	Check connectivity; if online:
      * ▪	Pull latest job updates (only diffs).
      * ▪	Push queued local changes.
  * ◦	Conflict logic:
    * ▪	Server considered source of truth for gate states.
    * ▪	If gate completed both locally and remotely with different data:
      * ▪	Mark “sync conflict” and flag for supervisor.
* •	Resilience:
  * ◦	Clear indication in UI when offline.
  * ◦	Queue status indicator (e.g., “5 updates pending sync”).

⠀
